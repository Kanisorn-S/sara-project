\documentclass[12pt,a4paper]{article}

% Packages
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{siunitx} 
\usepackage{caption}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{url}
\usepackage{cite}
\usepackage{listings}
\usepackage{listings-rust}
\usepackage{xurl}
\usepackage{siunitx}
\usepackage{tikz}

\lstset{language=Rust, style=boxed}
\geometry{margin=1in}
\graphicspath{{/images}}

\title{Sensors and Actuators for Robotics and
Automation\\Term Project Progress Report IV}
\author{Kanisorn Sangchai (ID: 6538020621)}
\date{November 17, 2025}

\begin{document}

\maketitle

\section{Introduction}
This report presents the design and implementation of an adjustable voltage divider circuit used to manipulate the temperature of a thermistor. The system is implemented using an STM32H743 core board by WeAct Studio, which powers and controls a digital potentiometer to regulate the heating voltage across a fixed resistor. The project further develops a mathematical model to relate potentiometer settings to the resulting temperature and applies a Kalman Filter to improve the accuracy of temperature measurements of our sensor. The source code for this project can be found in this GitHub repository: \url{https://github.com/Kanisorn-S/sara-project}. The source code for Milestone 3 can be found in the \texttt{Milestone-3} branch: \url{https://github.com/Kanisorn-S/sara-project/tree/Milestone-3}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{images/circuit_diagram.png}
    \caption{Circuit diagram of a temperature control and sensing system using an adjustable voltage divider and thermistor.}
    \label{fig:circuit}
\end{figure}

\section{Circuit Design}
The circuit design remains the same as in the previous milestone, as shown in Figure~\ref{fig:circuit}. 


\section{PI Controller Implementation}
\label{sec:pi-controller}

\subsection{Mathematical Model}

\subsubsection{Controller Design}

To achieve stable and accurate temperature control, we implemented a Proportional–Integral (PI) controller on the STM32H743VIT6 Core Board. The objective of the controller is to automatically adjust the system’s potentiometer value $\text{pot\_value}$ such that the measured temperature $T_{\text{measured}}$ matches the desired temperature $T_{\text{goal}}$.

The PI controller computes a control signal $u(t)$ based on the instantaneous temperature error
\begin{equation}
    e(t) = T_{\text{goal}} - T_{\text{measured}}
    \label{eq:pi-error}
\end{equation}
and the accumulation of past errors. The controller output is given by
\begin{equation}
    u(t) = K_P e(t) + K_I \int_0^t e(\tau)\, d\tau
    \label{eq:pi-eq}
\end{equation}
where $K_P$ and $K_I$ are the proportional and integral gains, respectively.

The proportional term $K_P e(t)$ provides an immediate correction proportional to the current error, giving the system fast response. The integral term $K_I \int e(t)\,dt$ eliminates the steady-state error by accumulating the past deviation from the target temperature, ensuring the system converges exactly to $T_{\text{set}}$ over time.

\subsubsection{Discretization}

Because the STM32 executes in discrete time steps, Equation~\eqref{eq:pi-eq} is implemented in its discrete form:
\begin{equation}
    u[k] = K_P e[k] + K_I \sum_{i=0}^{k} e[i] \Delta t
    \label{eq:pi-discrete}
\end{equation}
where $u[k]$ is the controller output at discrete time index $k$, and $\Delta t$ is the sampling interval.

The controller then updates the potentiometer value $\text{pot\_value}$ as:
\begin{equation}
    \text{pot\_value}_{\text{new}} = \text{POT\_VALUE} - u[k]
    \label{eq:pot-update}
\end{equation}
The subtraction in Equation~\eqref{eq:pot-update} ensures negative feedback: when the temperature is below the target (positive error), $u[k]$ becomes positive, thus decreasing $\text{pot\_value}$ to increase the heater voltage and raise the temperature. Conversely, when the temperature exceeds the target (negative error), $u[k]$ becomes negative, increasing $\text{pot\_value}$ to lower the heater voltage and reduce the temperature.

% \subsection{Integral Windup Prevention}

% A common issue in PI controllers is \textit{integral windup}, which occurs when the integral term accumulates excessively during actuator saturation. To mitigate this, the integral sum was clamped to a predefined limit:
% \begin{equation}
%     \text{integral} = 
%     \begin{cases}
%         I_{\text{max}}, & \text{if } \text{integral} > I_{\text{max}} \\
%         I_{\text{min}}, & \text{if } \text{integral} < I_{\text{min}} \\
%         \text{integral}, & \text{otherwise}
%     \end{cases}
%     \label{eq:anti-windup}
% \end{equation}
% where $I_{\text{max}}$ and $I_{\text{min}}$ are experimentally determined bounds that ensure system stability while preserving responsiveness.


\subsection{Implementation}

\subsubsection{Code Integration}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{images/main_control_flow.png}
    \caption{Flowchart of the main control and sensing loop integrating the PI controller.}
    \label{fig:main-control-flow}
\end{figure}

The PI controller was implemented in Rust and integrated into the main control and sensing loop, as shown in Listing~\ref{lst:pi-controller}. The control and sensing loop reads the measured temperature, compute the control signal, and update the digital potentiometer value following the flow shown in Figure~\ref{fig:main-control-flow}.

\begin{lstlisting}[caption={PI Controller Implementation in Rust}, label={lst:pi-controller}]
let mut integral: f32 = 0.0;
const KP: f32 = 0.8;
const KI: f32 = 0.02;
let mut pot_value: f32 = 0f32;

// Main control loop
loop {
    // 1. Get the current temperature from our 
    temperature sensor and Kalman filter
    let data: u32 = adc1.read(&mut channel).unwrap();

    // Kalman filter ...

    x_e = x_p + (K * (z - x_p));

    // 2. Compute instantaneous error
    let error = TARGET_TEMP - current_temp;

    // 3. Update integral term 
    integral += error * SAMPLE_PERIOD;

    // 4. Compute PI control output
    let control_signal = KP * error + KI * integral;

    // 5. Update potentiometer value 
    pot_value = pot_value - control_signal;
    pot_value = pot_value.clamp(0.0, 255.0);

    // 6. Send the new value to MCP41010 
    mcp41x.set_position(Channel::Ch0, pot_value).unwrap();

    delay_ms(SAMPLE_PERIOD_MS);
}
\end{lstlisting}

The proportional term provides an immediate correction based on the present temperature error, while the integral term accumulates the past errors to eliminate long-term bias. The subtraction in the potentiometer update ensures proper negative feedback: when the measured temperature is below the target, the controller reduces the potentiometer value, increasing heater power to raise the temperature.  

\subsubsection{Tuning}

The controller gains $K_P$ and $K_I$ were determined using the \textbf{Ziegler–Nichols closed-loop tuning method}, a systematic approach for finding stable and responsive control parameters.

\paragraph{Step 1: Determine the Ultimate Gain and Period.}
First, the integral term was disabled ($K_I = 0$), and the proportional gain $K_P$ was gradually increased until the system output began to oscillate with constant amplitude. This gain value is known as the \textit{ultimate gain} $K_u$, and the oscillation period is the \textit{ultimate period} $P_u$.

From the experiment:
\begin{align*}
    K_u &= 2.4 \\
    P_u &= 12.5~\text{s}
\end{align*}

\paragraph{Step 2: Apply Ziegler–Nichols Formula.}
For a PI controller, the Ziegler–Nichols tuning rule provides the following relationships:
\begin{align}
    K_P &= 0.45 K_u \label{eq:zn-kp}\\
    K_I &= \frac{1.2 K_P}{P_u} \label{eq:zn-ki}
\end{align}

Substituting the measured values of $K_u$ and $P_u$ gives:
\begin{align*}
    K_P &= 0.45(2.4) = 1.08 \\
    K_I &= \frac{1.2(1.08)}{12.5} = 0.104
\end{align*}

\paragraph{Step 3: Validation and Fine-Tuning.}
After applying these initial parameters, the system was tested under various target temperature settings. Small manual adjustments were made to slightly reduce $K_P$ (to 1.0) and $K_I$ (to 0.09) to minimize overshoot and improve stability without increasing settling time.

The final controller parameters were:
\begin{align*}
    K_P &= 1.0 \\
    K_I &= 0.09
\end{align*}


\section{Demonstration and Verification}

\section{Conclusion}
The adjustable voltage divider circuit was successfully implemented and mathematically modeled. All the necessary parameters for a Kalman filter were derived and utilized in the filtering process. The project progress include:
\begin{itemize}
\item Design and physical implementation of an adjustable voltage divider for temperature manipulation
\item Derivation of the thermal and electrical relationships governing the system
\item Experimental data collection for process and sensor noise estimation
\item Determination of system and sensor covariance values for Kalman Filter tuning
\item Demonstration of improved temperature measurement accuracy through Kalman filtering
\end{itemize}


\newpage
\bibliographystyle{IEEEtran}
\bibliography{ref}
